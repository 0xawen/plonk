var searchIndex = JSON.parse('{\
"dusk_plonk":{"doc":"                      ","i":[[0,"commitment_scheme","dusk_plonk","Ideally we should cleanly abstract away the polynomial…",null,null],[0,"kzg10","dusk_plonk::commitment_scheme","Implementation of the KZG10 polynomial commitment scheme.",null,null],[3,"Proof","dusk_plonk::commitment_scheme::kzg10","Proof that a polynomial `p` was correctly evaluated at a…",null,null],[12,"commitment_to_witness","","This is a commitment to the witness polynomial.",0,null],[12,"evaluated_point","","This is the result of evaluating a polynomial at the point…",0,null],[12,"commitment_to_polynomial","","This is the commitment to the polynomial that you want to…",0,null],[3,"AggregateProof","","Proof that multiple polynomials were correctly evaluated…",null,null],[12,"commitment_to_witness","","This is a commitment to the aggregated witness polynomial.",1,null],[12,"evaluated_points","","These are the results of the evaluating each polynomial at…",1,null],[12,"commitments_to_polynomials","","These are the commitments to the polynomials which you…",1,null],[3,"Commitment","","Holds a commitment to a polynomial in a form of a…",null,null],[12,"0","","The commitment is a group element.",2,null],[0,"errors","","Errors related to KZG10",null,null],[3,"PolyCommitSchemeError","dusk_plonk::commitment_scheme::kzg10::errors","Represents an error triggered on any of the Polynomial…",null,null],[4,"KZG10Errors","","Represents an error in the PublicParameters creation and…",null,null],[13,"DegreeIsZero","","This error occurs when the user tries to create…",3,null],[13,"TruncatedDegreeTooLarge","","This error occurs when the user tries to trim…",3,null],[13,"TruncatedDegreeIsZero","","This error occurs when the user tries to trim…",3,null],[13,"PolynomialDegreeTooLarge","","This error occurs when the user tries to commit to a…",3,null],[13,"PolynomialDegreeIsZero","","This error occurs when the user tries to commit to a…",3,null],[13,"PairingCheckFailure","","This error occurs when the pairing check fails at being…",3,null],[0,"key","dusk_plonk::commitment_scheme::kzg10","Key module contains the utilities and data structures that…",null,null],[3,"OpeningKey","dusk_plonk::commitment_scheme::kzg10::key","Opening Key is used to verify opening proofs made about a…",null,null],[12,"g","","The generator of G1.",4,null],[12,"h","","The generator of G2.",4,null],[12,"beta_h","","\\\\beta times the above generator of G2.",4,null],[12,"prepared_h","","The generator of G2, prepared for use in pairings.",4,null],[12,"prepared_beta_h","","\\\\beta times the above generator of G2, prepared for use in…",4,null],[3,"CommitKey","","CommitKey is used to commit to a polynomial which is…",null,null],[12,"powers_of_g","","Group elements of the form `{ \\\\beta^i G }`, where `i`…",5,null],[11,"max_degree","","Returns the maximum degree polynomial that you can commit…",5,[[]]],[11,"truncate","","Truncates the commit key to a lower max degree. Returns an…",5,[[],[["commitkey",3],["error",3],["result",4]]]],[11,"commit","","Commits to a polynomial returning the corresponding…",5,[[["polynomial",3]],[["error",3],["result",4],["commitment",3]]]],[11,"compute_single_witness","","For a given polynomial `p` and a point `z`, compute the…",5,[[["polynomial",3],["scalar",3]],["polynomial",3]]],[11,"open_single","","Creates an opening proof that a polynomial `p` was…",5,[[["polynomial",3],["scalar",3]],[["error",3],["result",4],["proof",3]]]],[11,"open_multiple","","Creates an opening proof that multiple polynomials were…",5,[[["vec",3],["scalar",3],["transcript",3],["scalar",3]],[["result",4],["aggregateproof",3],["error",3]]]],[11,"check","","Checks that a polynomial `p` was evaluated at a point `z`…",4,[[["proof",3],["scalar",3]]]],[11,"batch_check","","Checks whether a batch of polynomials evaluated at…",4,[[["transcript",3]],[["error",3],["result",4]]]],[0,"srs","dusk_plonk::commitment_scheme::kzg10","The Public Parameters can also be referred to as the…",null,null],[3,"PublicParameters","dusk_plonk::commitment_scheme::kzg10::srs","The Public Parameters can also be referred to as the…",null,null],[12,"commit_key","","Key used to generate proofs for composed circuits.",6,null],[12,"opening_key","","Key used to verify proofs for composed circuits.",6,null],[11,"setup","","Setup generates the public parameters using a random…",6,[[],[["error",3],["result",4],["publicparameters",3]]]],[11,"trim","","Trim truncates the prover key to allow the prover to…",6,[[],[["error",3],["result",4]]]],[11,"max_degree","","Max degree specifies the largest polynomial that this…",6,[[]]],[11,"with_witness","dusk_plonk::commitment_scheme::kzg10","Initialises an `AggregatedProof` with the commitment to…",1,[[["commitment",3]],["aggregateproof",3]]],[11,"add_part","","Adds an evaluated point with the commitment to the…",1,[[]]],[11,"flatten","","Flattens an `AggregateProof` into a `Proof`. The…",1,[[["transcript",3]],["proof",3]]],[11,"from_projective","","Builds a `Commitment` from a Bls12_381 `G1Projective` point.",2,[[["g1projective",3]]]],[11,"from_affine","","Builds a `Commitment` from a Bls12_381 `G1Affine` point.",2,[[["g1affine",3]]]],[11,"empty","","Builds an empty `Commitment` which is equivalent to the…",2,[[]]],[0,"constraint_system","dusk_plonk","The constraint System module stores the implementation of…",null,null],[3,"StandardComposer","dusk_plonk::constraint_system","A composer is a circuit builder and will dictate how a…",null,null],[3,"Variable","","The value is a reference to the actual value that was…",null,null],[4,"WireData","","Stores the data for a specific wire in an arithmetic…",null,null],[13,"Left","","Left Wire of n\'th gate",7,null],[13,"Right","","Right Wire of n\'th gate",7,null],[13,"Output","","Output Wire of n\'th gate",7,null],[13,"Fourth","","Fourth Wire of n\'th gate",7,null],[11,"circuit_size","","Returns the number of gates in the circuit",8,[[]]],[11,"new","","Generates a new empty `StandardComposer` with all of it\'s…",8,[[]]],[11,"add_witness_to_circuit_description","","Fixes a variable in the witness to be a part of the…",8,[[["scalar",3],["variable",3]]]],[11,"with_expected_size","","Creates a new circuit with an expected circuit size. This…",8,[[]]],[11,"add_input","","Add Input first calls the `Permutation` struct to generate…",8,[[["scalar",3]],["variable",3]]],[11,"add_constant_witness","","Adds the passed `BlsScalar` to the Constraint System as a…",8,[[["scalar",3]],["variable",3]]],[11,"poly_gate","","Adds a width-3 poly gate. This gate gives total freedom to…",8,[[["scalar",3],["variable",3]]]],[11,"constrain_to_constant","","Adds a gate which is designed to constrain a `Variable` to…",8,[[["scalar",3],["variable",3]]]],[11,"assert_equal","","Asserts that two variables are the same",8,[[["variable",3]]]],[11,"add_dummy_constraints","","This function is used to add a blinding factor to the…",8,[[]]],[0,"arithmetic","","Simple Arithmetic gates",null,null],[11,"add_gate","","Adds a width-3 add gate to the circuit, linking the…",8,[[["scalar",3],["variable",3]],["variable",3]]],[11,"big_add_gate","","Adds a width-4 add gate to the circuit and it\'s…",8,[[["scalar",3],["variable",3],["option",4]],["variable",3]]],[11,"mul_gate","","Adds a width-3 add gate to the circuit linking the product…",8,[[["scalar",3],["variable",3]],["variable",3]]],[11,"big_mul_gate","","Adds a width-4 `big_mul_gate` with the left, right and…",8,[[["scalar",3],["variable",3],["option",4]],["variable",3]]],[11,"add","","Adds a `big_addition_gate` with the left and right inputs…",8,[[["scalar",3]],["variable",3]]],[11,"big_add","","Adds a `big_addition_gate` with the left, right and fourth…",8,[[["option",4],["scalar",3]],["variable",3]]],[11,"mul","","Adds a simple and basic addition to the circuit between to…",8,[[["variable",3],["scalar",3]],["variable",3]]],[11,"big_mul","","Adds a width-4 `big_mul_gate` with the left, right and…",8,[[["variable",3],["scalar",3],["option",4]],["variable",3]]],[0,"boolean","","Boolean gate",null,null],[11,"boolean_gate","","Adds a boolean constraint (also known as binary…",8,[[["variable",3]],["variable",3]]],[0,"ecc","","Scalar multiplication gate",null,null],[3,"Point","dusk_plonk::constraint_system::ecc","Represents a JubJub point in the circuit",null,null],[3,"PointScalar","","The result of a scalar multiplication",null,null],[5,"curve_addition","","Adds two curve points together",null,[[["standardcomposer",3],["point",3]],["point",3]]],[5,"scalar_mul","","Computes a Scalar multiplication with the input scalar and…",null,[[["standardcomposer",3],["extendedpoint",3],["variable",3]],["pointscalar",3]]],[0,"gates","","Gates related to the ECC",null,null],[11,"assert_equal_public_point","dusk_plonk::constraint_system","Asserts that a point in the circuit is equal to a known…",8,[[["affinepoint",3],["point",3]]]],[11,"assert_equal_point","","Asserts that a point in the circuit is equal to another…",8,[[["point",3]]]],[11,"x","dusk_plonk::constraint_system::ecc","Return the X coordinate of the point",9,[[],["variable",3]]],[11,"y","","Return the Y coordinate of the point",9,[[],["variable",3]]],[11,"point","","Return the generated point",10,[[],["point",3]]],[11,"scalar","","Return the internal scalar",10,[[],["variable",3]]],[0,"logic","dusk_plonk::constraint_system","XOR and AND gates",null,null],[11,"xor_gate","","Adds a logical XOR gate that performs the XOR between two…",8,[[["variable",3]],["variable",3]]],[11,"and_gate","","Adds a logical AND gate that performs the bitwise AND…",8,[[["variable",3]],["variable",3]]],[0,"range","","Range gate",null,null],[11,"range_gate","","Adds a range-constraint gate that checks and constrains a…",8,[[["variable",3]]]],[0,"fft","dusk_plonk","FFT module contains the tools needed by the Composer…",null,null],[3,"EvaluationDomain","dusk_plonk::fft","Defines a domain over which finite field (I)FFTs can be…",null,null],[12,"size","","The size of the domain.",11,null],[12,"log_size_of_group","","`log_2(self.size)`.",11,null],[12,"size_as_field_element","","Size of the domain as a field element.",11,null],[12,"size_inv","","Inverse of the size in the field.",11,null],[12,"group_gen","","A generator of the subgroup.",11,null],[12,"group_gen_inv","","Inverse of the generator of the subgroup.",11,null],[12,"generator_inv","","Multiplicative generator of the finite field.",11,null],[3,"Evaluations","","Stores a polynomial in evaluation form.",null,null],[12,"evals","","The evaluations of a polynomial over the domain `D`",12,null],[3,"Polynomial","","Polynomial represents a polynomial in coeffiient form.",null,null],[12,"coeffs","","The coefficient of `x^i` is stored at location `i` in…",13,null],[11,"new","","Construct a domain that is large enough for evaluations of…",11,[[],[["error",3],["result",4]]]],[11,"compute_size_of_domain","","Return the size of a domain that is large enough for…",11,[[],["option",4]]],[11,"size","","Return the size of `self`.",11,[[]]],[11,"fft","","Compute a FFT.",11,[[],[["scalar",3],["vec",3]]]],[11,"fft_in_place","","Compute a FFT, modifying the vector in place.",11,[[["vec",3]]]],[11,"ifft","","Compute an IFFT.",11,[[],[["scalar",3],["vec",3]]]],[11,"ifft_in_place","","Compute an IFFT, modifying the vector in place.",11,[[["vec",3]]]],[11,"coset_fft","","Compute a FFT over a coset of the domain.",11,[[],[["scalar",3],["vec",3]]]],[11,"coset_fft_in_place","","Compute a FFT over a coset of the domain, modifying the…",11,[[["vec",3]]]],[11,"coset_ifft","","Compute an IFFT over a coset of the domain.",11,[[],[["scalar",3],["vec",3]]]],[11,"coset_ifft_in_place","","Compute an IFFT over a coset of the domain, modifying the…",11,[[["vec",3]]]],[11,"evaluate_all_lagrange_coefficients","","Evaluate all the lagrange polynomials defined by this…",11,[[["scalar",3]],[["scalar",3],["vec",3]]]],[11,"evaluate_vanishing_polynomial","","This evaluates the vanishing polynomial for this domain at…",11,[[["scalar",3]],["scalar",3]]],[11,"compute_vanishing_poly_over_coset","","Given that the domain size is `D` This function computes…",11,[[],["evaluations",3]]],[11,"elements","","Return an iterator over the elements of the domain.",11,[[],["elements",3]]],[11,"divide_by_vanishing_poly_on_coset_in_place","","The target polynomial is the zero polynomial in our…",11,[[]]],[11,"reindex_by_subdomain","","Given an index which assumes the first elements of this…",11,[[]]],[11,"mul_polynomials_in_evaluation_domain","","Perform O(n) multiplication of two polynomials that are…",11,[[],[["scalar",3],["vec",3]]]],[11,"from_vec_and_domain","","Construct `Self` from evaluations and a domain.",12,[[["vec",3],["evaluationdomain",3],["scalar",3]]]],[11,"interpolate_by_ref","","Interpolate a polynomial from a list of evaluations",12,[[],["polynomial",3]]],[11,"interpolate","","Interpolate a polynomial from a list of evaluations",12,[[],["polynomial",3]]],[11,"zero","","Returns the zero polynomial.",13,[[]]],[11,"is_zero","","Checks if the given polynomial is zero.",13,[[]]],[11,"from_coefficients_slice","","Constructs a new polynomial from a list of coefficients.",13,[[]]],[11,"from_coefficients_vec","","Constructs a new polynomial from a list of coefficients.",13,[[["vec",3],["scalar",3]]]],[11,"degree","","Returns the degree of the polynomial.",13,[[]]],[11,"evaluate","","Evaluates `self` at the given `point` in the field.",13,[[["scalar",3]],["scalar",3]]],[11,"rand","","Outputs a polynomial of degree `d` where each coefficient…",13,[[]]],[11,"ruffini","","Divides `self` by x-z using Ruffinis method",13,[[["scalar",3]],["polynomial",3]]],[0,"prelude","dusk_plonk","Collection of functions needed to use plonk library.",null,null],[3,"BlsScalar","dusk_plonk::prelude","Re-exported `dusk-bls12_381::Scalar`. Represents an…",null,null],[12,"0","","",14,null],[3,"JubJubScalar","","Re-exported `dusk-jubjub::Scalar`. Represents an element…",null,null],[3,"StandardComposer","","A composer is a circuit builder and will dictate how a…",null,null],[3,"Variable","","The value is a reference to the actual value that was…",null,null],[3,"ProverKey","","PLONK circuit proving key",null,null],[12,"arithmetic","","ProverKey for arithmetic gate",15,null],[12,"logic","","ProverKey for logic gate",15,null],[12,"range","","ProverKey for range gate",15,null],[12,"ecc","","ProverKey for ecc gate",15,null],[12,"permutation","","ProverKey for permutation checks",15,null],[3,"VerifierKey","","PLONK circuit verification key",null,null],[12,"n","","Circuit size",16,null],[12,"arithmetic","","VerifierKey for arithmetic gates",16,null],[12,"logic","","VerifierKey for logic gates",16,null],[12,"range","","VerifierKey for range gates",16,null],[12,"ecc","","VerifierKey for ecc gates",16,null],[12,"permutation","","VerifierKey for permutation checks",16,null],[0,"plonk_errors","","Collection of errors that the library exposes/uses.",null,null],[3,"ProvingError","dusk_plonk::prelude::plonk_errors","Represents an error on the Proving stage.",null,null],[3,"FFTError","","Represents an error triggered on any of the FFT module…",null,null],[3,"ProofError","","Represents an error triggered on any of the proof_system…",null,null],[4,"PreProcessingError","","Represents an error on the Circuit preprocessing stage.",null,null],[13,"MissmatchedPolyLen","","This error occurs when an error triggers during the…",17,null],[4,"FFTErrors","","Defines all of the possible FFTError types that we could…",null,null],[13,"InvalidEvalDomainSize","","This error occurs when an error triggers on any of the fft…",18,null],[12,"log_size_of_group","dusk_plonk::prelude::plonk_errors::FFTErrors","Log size of the group",19,null],[12,"adacity","","Two adacity generated",19,null],[4,"ProofErrors","dusk_plonk::prelude::plonk_errors","Defines all of the possible ProofError types that we could…",null,null],[13,"ProofVerificationError","","This error occurs when the verification of a `Proof` fails.",20,null],[13,"CircuitAlreadyPreprocessed","","This error occurrs when the Prover structure already…",20,null],[0,"proof_system","dusk_plonk","proving system",null,null],[11,"preprocess_prover","dusk_plonk::constraint_system","These are the parts of preprocessing that the prover must…",8,[[["transcript",3],["commitkey",3]],[["result",4],["proverkey",3],["error",3]]]],[11,"preprocess_verifier","","The verifier only requires the commitments in order to…",8,[[["transcript",3],["commitkey",3]],[["error",3],["verifierkey",3],["result",4]]]],[0,"proof","dusk_plonk::proof_system","Represents a PLONK Proof A Proof stores the commitments to…",null,null],[3,"Proof","dusk_plonk::proof_system::proof","A Proof is a composition of `Commitments` to the witness,…",null,null],[12,"a_comm","","Commitment to the witness polynomial for the left wires.",21,null],[12,"b_comm","","Commitment to the witness polynomial for the right wires.",21,null],[12,"c_comm","","Commitment to the witness polynomial for the output wires.",21,null],[12,"d_comm","","Commitment to the witness polynomial for the fourth wires.",21,null],[12,"z_comm","","Commitment to the permutation polynomial.",21,null],[12,"t_1_comm","","Commitment to the quotient polynomial.",21,null],[12,"t_2_comm","","Commitment to the quotient polynomial.",21,null],[12,"t_3_comm","","Commitment to the quotient polynomial.",21,null],[12,"t_4_comm","","Commitment to the quotient polynomial.",21,null],[12,"w_z_comm","","Commitment to the opening polynomial.",21,null],[12,"w_zw_comm","","Commitment to the shifted opening polynomial.",21,null],[12,"evaluations","","Subset of all of the evaluations added to the proof.",21,null],[0,"prover","dusk_plonk::proof_system","Represents a PLONK Prover",null,null],[3,"Prover","dusk_plonk::proof_system::prover","Prover composes a circuit and builds a proof",null,null],[12,"prover_key","","ProverKey which is used to create proofs about a specific…",22,null],[12,"preprocessed_transcript","","Store the messages exchanged during the preprocessing…",22,null],[11,"mut_cs","","Returns a mutable copy of the underlying composer",22,[[],["standardcomposer",3]]],[11,"preprocess","","Preprocesses the underlying constraint system",22,[[["commitkey",3]],[["error",3],["result",4]]]],[11,"new","","Creates a new prover object",22,[[],["prover",3]]],[11,"circuit_size","","Returns the number of gates in the circuit",22,[[]]],[11,"clear_witness","","Resets the witnesses in the prover object. This function…",22,[[]]],[11,"clear","","Clears all data in the Prover This function is used when…",22,[[]]],[11,"key_transcript","","Keys the transcript with additional seed information…",22,[[]]],[11,"prove_with_preprocessed","","Creates a Proof that a circuit is satisfied Note that if…",22,[[["proverkey",3],["commitkey",3]],[["error",3],["proof",3],["result",4]]]],[11,"prove","","Proves a circuit is satisfied, then clears the witness…",22,[[["commitkey",3]],[["error",3],["proof",3],["result",4]]]],[0,"verifier","dusk_plonk::proof_system","Represents a PLONK Verifier",null,null],[3,"Verifier","dusk_plonk::proof_system::verifier","Verifier verifies a proof",null,null],[12,"verifier_key","","VerificationKey which is used to verify a specific PLONK…",23,null],[12,"preprocessed_transcript","","Store the messages exchanged during the preprocessing…",23,null],[11,"new","","Creates a new verifier object",23,[[],["verifier",3]]],[11,"circuit_size","","Returns the number of gates in the circuit",23,[[]]],[11,"mut_cs","","Returns a mutable copy of the underlying composer",23,[[],["standardcomposer",3]]],[11,"preprocess","","Preprocess a proof",23,[[["commitkey",3]],[["error",3],["result",4]]]],[11,"key_transcript","","Keys the transcript with additional seed information…",23,[[]]],[11,"verify","","Verifies a proof",23,[[["openingkey",3],["proof",3]],[["error",3],["result",4]]]],[0,"transcript","dusk_plonk","This is an extension over the Merlin Transcript which adds…",null,null],[8,"TranscriptProtocol","dusk_plonk::transcript","Transcript adds an abstraction over the Merlin transcript…",null,null],[10,"append_commitment","","Append a `commitment` with the given `label`.",24,[[["commitment",3]]]],[10,"append_scalar","","Append a `Scalar` with the given `label`.",24,[[["scalar",3]]]],[10,"challenge_scalar","","Compute a `label`ed challenge variable.",24,[[],["scalar",3]]],[10,"circuit_domain_sep","","Append domain separator for the circuit size.",24,[[]]],[0,"notes","dusk_plonk","This module is a self contained file which explains how…",null,null],[0,"commitment_schemes","dusk_plonk::notes","This module explains the inner workings of commitment…",null,null],[0,"permutation_arguments","","Contained within this module are the notes on how the…",null,null],[0,"snark_construction","","This module contains the methodology of how zk-SNARKS are…",null,null],[0,"prove_verify","","This module contains the notes on how the prover algorithm…",null,null],[0,"unbalanced_perm_args","","Contained within this module are the notes on how the…",null,null],[0,"kzg10_docs","","In this module we show how, and why, the KZG10 polynomial…",null,null],[11,"from","dusk_plonk::commitment_scheme::kzg10","",0,[[]]],[11,"into","","",0,[[]]],[11,"to_owned","","",0,[[]]],[11,"clone_into","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"try_into","","",0,[[],["result",4]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"vzip","","",0,[[]]],[11,"from","","",1,[[]]],[11,"into","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"try_into","","",1,[[],["result",4]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"vzip","","",1,[[]]],[11,"from","","",2,[[]]],[11,"into","","",2,[[]]],[11,"to_owned","","",2,[[]]],[11,"clone_into","","",2,[[]]],[11,"try_from","","",2,[[],["result",4]]],[11,"try_into","","",2,[[],["result",4]]],[11,"borrow","","",2,[[]]],[11,"borrow_mut","","",2,[[]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"vzip","","",2,[[]]],[11,"from","dusk_plonk::commitment_scheme::kzg10::errors","",25,[[]]],[11,"into","","",25,[[]]],[11,"to_string","","",25,[[],["string",3]]],[11,"try_from","","",25,[[],["result",4]]],[11,"try_into","","",25,[[],["result",4]]],[11,"borrow","","",25,[[]]],[11,"borrow_mut","","",25,[[]]],[11,"type_id","","",25,[[],["typeid",3]]],[11,"as_fail","","",25,[[],["fail",8]]],[11,"vzip","","",25,[[]]],[11,"from","","",3,[[]]],[11,"into","","",3,[[]]],[11,"to_string","","",3,[[],["string",3]]],[11,"try_from","","",3,[[],["result",4]]],[11,"try_into","","",3,[[],["result",4]]],[11,"borrow","","",3,[[]]],[11,"borrow_mut","","",3,[[]]],[11,"type_id","","",3,[[],["typeid",3]]],[11,"as_fail","","",3,[[],["fail",8]]],[11,"vzip","","",3,[[]]],[11,"from","dusk_plonk::commitment_scheme::kzg10::key","",4,[[]]],[11,"into","","",4,[[]]],[11,"to_owned","","",4,[[]]],[11,"clone_into","","",4,[[]]],[11,"try_from","","",4,[[],["result",4]]],[11,"try_into","","",4,[[],["result",4]]],[11,"borrow","","",4,[[]]],[11,"borrow_mut","","",4,[[]]],[11,"type_id","","",4,[[],["typeid",3]]],[11,"vzip","","",4,[[]]],[11,"from","","",5,[[]]],[11,"into","","",5,[[]]],[11,"try_from","","",5,[[],["result",4]]],[11,"try_into","","",5,[[],["result",4]]],[11,"borrow","","",5,[[]]],[11,"borrow_mut","","",5,[[]]],[11,"type_id","","",5,[[],["typeid",3]]],[11,"vzip","","",5,[[]]],[11,"from","dusk_plonk::commitment_scheme::kzg10::srs","",6,[[]]],[11,"into","","",6,[[]]],[11,"try_from","","",6,[[],["result",4]]],[11,"try_into","","",6,[[],["result",4]]],[11,"borrow","","",6,[[]]],[11,"borrow_mut","","",6,[[]]],[11,"type_id","","",6,[[],["typeid",3]]],[11,"vzip","","",6,[[]]],[11,"from","dusk_plonk::constraint_system","",8,[[]]],[11,"into","","",8,[[]]],[11,"try_from","","",8,[[],["result",4]]],[11,"try_into","","",8,[[],["result",4]]],[11,"borrow","","",8,[[]]],[11,"borrow_mut","","",8,[[]]],[11,"type_id","","",8,[[],["typeid",3]]],[11,"vzip","","",8,[[]]],[11,"from","","",26,[[]]],[11,"into","","",26,[[]]],[11,"to_owned","","",26,[[]]],[11,"clone_into","","",26,[[]]],[11,"try_from","","",26,[[],["result",4]]],[11,"try_into","","",26,[[],["result",4]]],[11,"borrow","","",26,[[]]],[11,"borrow_mut","","",26,[[]]],[11,"type_id","","",26,[[],["typeid",3]]],[11,"vzip","","",26,[[]]],[11,"from","","",7,[[]]],[11,"into","","",7,[[]]],[11,"to_owned","","",7,[[]]],[11,"clone_into","","",7,[[]]],[11,"try_from","","",7,[[],["result",4]]],[11,"try_into","","",7,[[],["result",4]]],[11,"borrow","","",7,[[]]],[11,"borrow_mut","","",7,[[]]],[11,"type_id","","",7,[[],["typeid",3]]],[11,"vzip","","",7,[[]]],[11,"from","dusk_plonk::prelude::plonk_errors","",27,[[]]],[11,"into","","",27,[[]]],[11,"to_string","","",27,[[],["string",3]]],[11,"try_from","","",27,[[],["result",4]]],[11,"try_into","","",27,[[],["result",4]]],[11,"borrow","","",27,[[]]],[11,"borrow_mut","","",27,[[]]],[11,"type_id","","",27,[[],["typeid",3]]],[11,"as_fail","","",27,[[],["fail",8]]],[11,"vzip","","",27,[[]]],[11,"from","","",17,[[]]],[11,"into","","",17,[[]]],[11,"to_string","","",17,[[],["string",3]]],[11,"try_from","","",17,[[],["result",4]]],[11,"try_into","","",17,[[],["result",4]]],[11,"borrow","","",17,[[]]],[11,"borrow_mut","","",17,[[]]],[11,"type_id","","",17,[[],["typeid",3]]],[11,"as_fail","","",17,[[],["fail",8]]],[11,"vzip","","",17,[[]]],[11,"from","dusk_plonk::constraint_system::ecc","",9,[[]]],[11,"into","","",9,[[]]],[11,"to_owned","","",9,[[]]],[11,"clone_into","","",9,[[]]],[11,"try_from","","",9,[[],["result",4]]],[11,"try_into","","",9,[[],["result",4]]],[11,"borrow","","",9,[[]]],[11,"borrow_mut","","",9,[[]]],[11,"type_id","","",9,[[],["typeid",3]]],[11,"vzip","","",9,[[]]],[11,"from","","",10,[[]]],[11,"into","","",10,[[]]],[11,"to_owned","","",10,[[]]],[11,"clone_into","","",10,[[]]],[11,"try_from","","",10,[[],["result",4]]],[11,"try_into","","",10,[[],["result",4]]],[11,"borrow","","",10,[[]]],[11,"borrow_mut","","",10,[[]]],[11,"type_id","","",10,[[],["typeid",3]]],[11,"vzip","","",10,[[]]],[11,"from","dusk_plonk::fft","",11,[[]]],[11,"into","","",11,[[]]],[11,"to_owned","","",11,[[]]],[11,"clone_into","","",11,[[]]],[11,"try_from","","",11,[[],["result",4]]],[11,"try_into","","",11,[[],["result",4]]],[11,"borrow","","",11,[[]]],[11,"borrow_mut","","",11,[[]]],[11,"type_id","","",11,[[],["typeid",3]]],[11,"vzip","","",11,[[]]],[11,"from","","",12,[[]]],[11,"into","","",12,[[]]],[11,"to_owned","","",12,[[]]],[11,"clone_into","","",12,[[]]],[11,"try_from","","",12,[[],["result",4]]],[11,"try_into","","",12,[[],["result",4]]],[11,"borrow","","",12,[[]]],[11,"borrow_mut","","",12,[[]]],[11,"type_id","","",12,[[],["typeid",3]]],[11,"vzip","","",12,[[]]],[11,"from","","",13,[[]]],[11,"into","","",13,[[]]],[11,"to_owned","","",13,[[]]],[11,"clone_into","","",13,[[]]],[11,"try_from","","",13,[[],["result",4]]],[11,"try_into","","",13,[[],["result",4]]],[11,"borrow","","",13,[[]]],[11,"borrow_mut","","",13,[[]]],[11,"type_id","","",13,[[],["typeid",3]]],[11,"vzip","","",13,[[]]],[11,"from","dusk_plonk::prelude::plonk_errors","",28,[[]]],[11,"into","","",28,[[]]],[11,"to_string","","",28,[[],["string",3]]],[11,"try_from","","",28,[[],["result",4]]],[11,"try_into","","",28,[[],["result",4]]],[11,"borrow","","",28,[[]]],[11,"borrow_mut","","",28,[[]]],[11,"type_id","","",28,[[],["typeid",3]]],[11,"as_fail","","",28,[[],["fail",8]]],[11,"vzip","","",28,[[]]],[11,"from","","",18,[[]]],[11,"into","","",18,[[]]],[11,"to_string","","",18,[[],["string",3]]],[11,"try_from","","",18,[[],["result",4]]],[11,"try_into","","",18,[[],["result",4]]],[11,"borrow","","",18,[[]]],[11,"borrow_mut","","",18,[[]]],[11,"type_id","","",18,[[],["typeid",3]]],[11,"as_fail","","",18,[[],["fail",8]]],[11,"vzip","","",18,[[]]],[11,"from","dusk_plonk::prelude","",14,[[]]],[11,"into","","",14,[[]]],[11,"to_owned","","",14,[[]]],[11,"clone_into","","",14,[[]]],[11,"try_from","","",14,[[],["result",4]]],[11,"try_into","","",14,[[],["result",4]]],[11,"borrow","","",14,[[]]],[11,"borrow_mut","","",14,[[]]],[11,"type_id","","",14,[[],["typeid",3]]],[11,"vzip","","",14,[[]]],[11,"conditional_negate","","",14,[[["choice",3]]]],[11,"from","","",29,[[]]],[11,"into","","",29,[[]]],[11,"to_owned","","",29,[[]]],[11,"clone_into","","",29,[[]]],[11,"try_from","","",29,[[],["result",4]]],[11,"try_into","","",29,[[],["result",4]]],[11,"borrow","","",29,[[]]],[11,"borrow_mut","","",29,[[]]],[11,"type_id","","",29,[[],["typeid",3]]],[11,"vzip","","",29,[[]]],[11,"conditional_negate","","",29,[[["choice",3]]]],[11,"from","","",15,[[]]],[11,"into","","",15,[[]]],[11,"try_from","","",15,[[],["result",4]]],[11,"try_into","","",15,[[],["result",4]]],[11,"borrow","","",15,[[]]],[11,"borrow_mut","","",15,[[]]],[11,"type_id","","",15,[[],["typeid",3]]],[11,"vzip","","",15,[[]]],[11,"from","","",16,[[]]],[11,"into","","",16,[[]]],[11,"try_from","","",16,[[],["result",4]]],[11,"try_into","","",16,[[],["result",4]]],[11,"borrow","","",16,[[]]],[11,"borrow_mut","","",16,[[]]],[11,"type_id","","",16,[[],["typeid",3]]],[11,"vzip","","",16,[[]]],[11,"from","dusk_plonk::prelude::plonk_errors","",30,[[]]],[11,"into","","",30,[[]]],[11,"to_string","","",30,[[],["string",3]]],[11,"try_from","","",30,[[],["result",4]]],[11,"try_into","","",30,[[],["result",4]]],[11,"borrow","","",30,[[]]],[11,"borrow_mut","","",30,[[]]],[11,"type_id","","",30,[[],["typeid",3]]],[11,"as_fail","","",30,[[],["fail",8]]],[11,"vzip","","",30,[[]]],[11,"from","","",20,[[]]],[11,"into","","",20,[[]]],[11,"to_string","","",20,[[],["string",3]]],[11,"try_from","","",20,[[],["result",4]]],[11,"try_into","","",20,[[],["result",4]]],[11,"borrow","","",20,[[]]],[11,"borrow_mut","","",20,[[]]],[11,"type_id","","",20,[[],["typeid",3]]],[11,"as_fail","","",20,[[],["fail",8]]],[11,"vzip","","",20,[[]]],[11,"from","dusk_plonk::proof_system::proof","",21,[[]]],[11,"into","","",21,[[]]],[11,"try_from","","",21,[[],["result",4]]],[11,"try_into","","",21,[[],["result",4]]],[11,"borrow","","",21,[[]]],[11,"borrow_mut","","",21,[[]]],[11,"type_id","","",21,[[],["typeid",3]]],[11,"vzip","","",21,[[]]],[11,"from","dusk_plonk::proof_system::prover","",22,[[]]],[11,"into","","",22,[[]]],[11,"try_from","","",22,[[],["result",4]]],[11,"try_into","","",22,[[],["result",4]]],[11,"borrow","","",22,[[]]],[11,"borrow_mut","","",22,[[]]],[11,"type_id","","",22,[[],["typeid",3]]],[11,"vzip","","",22,[[]]],[11,"from","dusk_plonk::proof_system::verifier","",23,[[]]],[11,"into","","",23,[[]]],[11,"try_from","","",23,[[],["result",4]]],[11,"try_into","","",23,[[],["result",4]]],[11,"borrow","","",23,[[]]],[11,"borrow_mut","","",23,[[]]],[11,"type_id","","",23,[[],["typeid",3]]],[11,"vzip","","",23,[[]]],[11,"bitxor","dusk_plonk::prelude","",14,[[["scalar",3]],["scalar",3]]],[11,"add","","",14,[[["scalar",3]],["scalar",3]]],[11,"add","","",14,[[["scalar",3]],["scalar",3]]],[11,"clone","","",14,[[],["scalar",3]]],[11,"product","","",14,[[],["scalar",3]]],[11,"from","","",14,[[],["scalar",3]]],[11,"mul","","",14,[[["scalar",3]],["scalar",3]]],[11,"mul","","",14,[[["scalar",3]],["scalar",3]]],[11,"eq","","",14,[[["scalar",3]]]],[11,"add_assign","","",14,[[["scalar",3]]]],[11,"add_assign","","",14,[[["scalar",3]]]],[11,"default","","",14,[[],["scalar",3]]],[11,"fmt","","",14,[[["formatter",3]],[["error",3],["result",4]]]],[11,"neg","","",14,[[],["scalar",3]]],[11,"mul_assign","","",14,[[["scalar",3]]]],[11,"mul_assign","","",14,[[["scalar",3]]]],[11,"cmp","","",14,[[["scalar",3]],["ordering",4]]],[11,"partial_cmp","","",14,[[["scalar",3]],[["ordering",4],["option",4]]]],[11,"deserialize","","",14,[[],[["scalar",3],["result",4]]]],[11,"sub_assign","","",14,[[["scalar",3]]]],[11,"sub_assign","","",14,[[["scalar",3]]]],[11,"bitand","","",14,[[["scalar",3]],["scalar",3]]],[11,"sum","","",14,[[],["scalar",3]]],[11,"serialize","","",14,[[],["result",4]]],[11,"ct_eq","","",14,[[["scalar",3]],["choice",3]]],[11,"conditional_select","","",14,[[["choice",3],["scalar",3]],["scalar",3]]],[11,"sub","","",14,[[["scalar",3]],["scalar",3]]],[11,"sub","","",14,[[["scalar",3]],["scalar",3]]],[11,"sub","","",29,[[["fr",3]],["fr",3]]],[11,"sub","","",29,[[["fr",3]],["fr",3]]],[11,"ct_eq","","",29,[[["fr",3]],["choice",3]]],[11,"partial_cmp","","",29,[[["fr",3]],[["ordering",4],["option",4]]]],[11,"fmt","","",29,[[["formatter",3]],[["error",3],["result",4]]]],[11,"sub_assign","","",29,[[["fr",3]]]],[11,"sub_assign","","",29,[[["fr",3]]]],[11,"mul","","",29,[[["fr",3]],["fr",3]]],[11,"mul","","",29,[[["fr",3]],["fr",3]]],[11,"mul_assign","","",29,[[["fr",3]]]],[11,"mul_assign","","",29,[[["fr",3]]]],[11,"cmp","","",29,[[["fr",3]],["ordering",4]]],[11,"neg","","",29,[[],["fr",3]]],[11,"conditional_select","","",29,[[["choice",3],["fr",3]],["fr",3]]],[11,"index","","",29,[[]]],[11,"index_mut","","",29,[[]]],[11,"add_assign","","",29,[[["fr",3]]]],[11,"add_assign","","",29,[[["fr",3]]]],[11,"from","","",29,[[],["fr",3]]],[11,"from","","",29,[[],["fr",3]]],[11,"from","","",14,[[["fr",3]],["scalar",3]]],[11,"eq","","",29,[[["fr",3]]]],[11,"default","","",29,[[],["fr",3]]],[11,"add","","",29,[[["fr",3]],["fr",3]]],[11,"add","","",29,[[["fr",3]],["fr",3]]],[11,"clone","","",29,[[],["fr",3]]],[11,"from","dusk_plonk::constraint_system::ecc","",9,[[["pointscalar",3]],["point",3]]],[11,"into","dusk_plonk::constraint_system","",26,[[]]],[11,"clone","dusk_plonk::commitment_scheme::kzg10::key","",4,[[],["openingkey",3]]],[11,"clone","dusk_plonk::commitment_scheme::kzg10","",0,[[],["proof",3]]],[11,"clone","","",2,[[],["commitment",3]]],[11,"clone","dusk_plonk::constraint_system","",26,[[],["variable",3]]],[11,"clone","","",7,[[],["wiredata",4]]],[11,"clone","dusk_plonk::constraint_system::ecc","",9,[[],["point",3]]],[11,"clone","","",10,[[],["pointscalar",3]]],[11,"clone","dusk_plonk::fft","",11,[[],["evaluationdomain",3]]],[11,"clone","","",12,[[],["evaluations",3]]],[11,"clone","","",13,[[],["polynomial",3]]],[11,"default","dusk_plonk::commitment_scheme::kzg10","",2,[[]]],[11,"default","dusk_plonk::constraint_system","",8,[[]]],[11,"default","dusk_plonk::proof_system::prover","",22,[[],["prover",3]]],[11,"default","dusk_plonk::proof_system::verifier","",23,[[],["verifier",3]]],[11,"eq","dusk_plonk::commitment_scheme::kzg10","",2,[[["commitment",3]]]],[11,"ne","","",2,[[["commitment",3]]]],[11,"eq","dusk_plonk::constraint_system","",26,[[["variable",3]]]],[11,"ne","","",26,[[["variable",3]]]],[11,"eq","","",7,[[["wiredata",4]]]],[11,"ne","","",7,[[["wiredata",4]]]],[11,"eq","dusk_plonk::fft","",11,[[["evaluationdomain",3]]]],[11,"ne","","",11,[[["evaluationdomain",3]]]],[11,"eq","","",12,[[["evaluations",3]]]],[11,"ne","","",12,[[["evaluations",3]]]],[11,"eq","","",13,[[["polynomial",3]]]],[11,"ne","","",13,[[["polynomial",3]]]],[11,"eq","dusk_plonk::proof_system::proof","",21,[[["proof",3]]]],[11,"ne","","",21,[[["proof",3]]]],[11,"deref","dusk_plonk::fft","",13,[[]]],[11,"deref_mut","","",13,[[]]],[11,"fmt","dusk_plonk::commitment_scheme::kzg10::errors","",3,[[["formatter",3]],["result",6]]],[11,"fmt","","",25,[[["formatter",3]],["result",6]]],[11,"fmt","dusk_plonk::commitment_scheme::kzg10::key","",4,[[["formatter",3]],["result",6]]],[11,"fmt","","",5,[[["formatter",3]],["result",6]]],[11,"fmt","dusk_plonk::commitment_scheme::kzg10::srs","",6,[[["formatter",3]],["result",6]]],[11,"fmt","dusk_plonk::commitment_scheme::kzg10","",0,[[["formatter",3]],["result",6]]],[11,"fmt","","",1,[[["formatter",3]],["result",6]]],[11,"fmt","","",2,[[["formatter",3]],["result",6]]],[11,"fmt","dusk_plonk::constraint_system","",8,[[["formatter",3]],["result",6]]],[11,"fmt","dusk_plonk::prelude::plonk_errors","",17,[[["formatter",3]],["result",6]]],[11,"fmt","","",27,[[["formatter",3]],["result",6]]],[11,"fmt","dusk_plonk::constraint_system","",26,[[["formatter",3]],["result",6]]],[11,"fmt","","",7,[[["formatter",3]],["result",6]]],[11,"fmt","dusk_plonk::constraint_system::ecc","",9,[[["formatter",3]],["result",6]]],[11,"fmt","","",10,[[["formatter",3]],["result",6]]],[11,"fmt","dusk_plonk::fft","",11,[[["formatter",3]],["result",6]]],[11,"fmt","","",12,[[["formatter",3]],["result",6]]],[11,"fmt","dusk_plonk::prelude::plonk_errors","",18,[[["formatter",3]],["result",6]]],[11,"fmt","","",28,[[["formatter",3]],["result",6]]],[11,"fmt","dusk_plonk::fft","",13,[[["formatter",3]],["result",6]]],[11,"fmt","dusk_plonk::proof_system::proof","",21,[[["formatter",3]],["result",6]]],[11,"fmt","dusk_plonk::prelude::plonk_errors","",20,[[["formatter",3]],["result",6]]],[11,"fmt","","",30,[[["formatter",3]],["result",6]]],[11,"fmt","dusk_plonk::prelude","",15,[[["formatter",3]],["result",6]]],[11,"fmt","","",16,[[["formatter",3]],["result",6]]],[11,"fmt","dusk_plonk::commitment_scheme::kzg10::errors","",3,[[["formatter",3]],["result",6]]],[11,"fmt","","",25,[[["formatter",3]],["result",6]]],[11,"fmt","dusk_plonk::prelude::plonk_errors","",17,[[["formatter",3]],["result",6]]],[11,"fmt","","",27,[[["formatter",3]],["result",6]]],[11,"fmt","","",18,[[["formatter",3]],["result",6]]],[11,"fmt","","",28,[[["formatter",3]],["result",6]]],[11,"fmt","","",20,[[["formatter",3]],["result",6]]],[11,"fmt","","",30,[[["formatter",3]],["result",6]]],[11,"neg","dusk_plonk::fft","",13,[[],["polynomial",3]]],[11,"add_assign","","",12,[[["evaluations",3]]]],[11,"add_assign","","",13,[[["polynomial",3]]]],[11,"add_assign","","",13,[[]]],[11,"sub_assign","","",12,[[["evaluations",3]]]],[11,"sub_assign","","",13,[[["polynomial",3]]]],[11,"mul_assign","","",12,[[["evaluations",3]]]],[11,"div_assign","","",12,[[["evaluations",3]]]],[11,"index","","",12,[[],["scalar",3]]],[11,"hash","dusk_plonk::constraint_system","",26,[[]]],[11,"sum","dusk_plonk::fft","",13,[[]]],[11,"name","dusk_plonk::commitment_scheme::kzg10::errors","",3,[[],["option",4]]],[11,"cause","","",3,[[],[["fail",8],["option",4]]]],[11,"backtrace","","",3,[[],[["backtrace",3],["option",4]]]],[11,"name","","",25,[[],["option",4]]],[11,"cause","","",25,[[],[["fail",8],["option",4]]]],[11,"backtrace","","",25,[[],[["backtrace",3],["option",4]]]],[11,"name","dusk_plonk::prelude::plonk_errors","",17,[[],["option",4]]],[11,"cause","","",17,[[],[["fail",8],["option",4]]]],[11,"backtrace","","",17,[[],[["backtrace",3],["option",4]]]],[11,"name","","",27,[[],["option",4]]],[11,"cause","","",27,[[],[["fail",8],["option",4]]]],[11,"backtrace","","",27,[[],[["backtrace",3],["option",4]]]],[11,"name","","",18,[[],["option",4]]],[11,"cause","","",18,[[],[["fail",8],["option",4]]]],[11,"backtrace","","",18,[[],[["backtrace",3],["option",4]]]],[11,"name","","",28,[[],["option",4]]],[11,"cause","","",28,[[],[["fail",8],["option",4]]]],[11,"backtrace","","",28,[[],[["backtrace",3],["option",4]]]],[11,"name","","",20,[[],["option",4]]],[11,"cause","","",20,[[],[["fail",8],["option",4]]]],[11,"backtrace","","",20,[[],[["backtrace",3],["option",4]]]],[11,"name","","",30,[[],["option",4]]],[11,"cause","","",30,[[],[["fail",8],["option",4]]]],[11,"backtrace","","",30,[[],[["backtrace",3],["option",4]]]],[11,"zero","dusk_plonk::prelude","Returns zero, the additive identity.",14,[[],["scalar",3]]],[11,"one","","Returns one, the multiplicative identity.",14,[[],["scalar",3]]],[11,"internal_repr","","Returns the internal representation of the Scalar.",14,[[]]],[11,"double","","Doubles this field element.",14,[[],["scalar",3]]],[11,"from_bytes","","Attempts to convert a little-endian byte representation of…",14,[[],[["scalar",3],["ctoption",3]]]],[11,"to_bytes","","Converts an element of `Scalar` into a byte representation…",14,[[]]],[11,"to_bits","","Returns the bit representation of the given `Scalar` as an…",14,[[]]],[11,"from_bytes_wide","","Converts a 512-bit little endian integer into a `Scalar`…",14,[[],["scalar",3]]],[11,"from_raw","","Converts from an integer represented in little endian into…",14,[[],["scalar",3]]],[11,"random","","Generate a valid Scalar choosen uniformly using user-…",14,[[],["scalar",3]]],[11,"reduce","","Reduces the scalar and returns it multiplied by the…",14,[[],["scalar",3]]],[11,"square","","Squares this element.",14,[[],["scalar",3]]],[11,"sqrt","","Computes the square root of this element, if it exists.",14,[[],[["scalar",3],["ctoption",3]]]],[11,"pow","","Exponentiates `self` by `by`, where `by` is a…",14,[[],["scalar",3]]],[11,"pow_vartime","","Exponentiates `self` by `by`, where `by` is a…",14,[[],["scalar",3]]],[11,"invert","","Computes the multiplicative inverse of this element,…",14,[[],[["scalar",3],["ctoption",3]]]],[11,"mul","","Multiplies `rhs` by `self`, returning the result.",14,[[["scalar",3]],["scalar",3]]],[11,"sub","","Subtracts `rhs` from `self`, returning the result.",14,[[["scalar",3]],["scalar",3]]],[11,"add","","Adds `rhs` to `self`, returning the result.",14,[[["scalar",3]],["scalar",3]]],[11,"neg","","Negates `self`.",14,[[],["scalar",3]]],[11,"divn","","SHR impl",14,[[]]],[11,"zero","","Returns zero, the additive identity.",29,[[],["fr",3]]],[11,"one","","Returns one, the multiplicative identity.",29,[[],["fr",3]]],[11,"double","","Doubles this field element.",29,[[],["fr",3]]],[11,"divn","","SHR impl",29,[[]]],[11,"from_bytes","","Attempts to convert a little-endian byte representation of…",29,[[],[["fr",3],["ctoption",3]]]],[11,"to_bytes","","Converts an element of `Fr` into a byte representation in…",29,[[]]],[11,"from_bytes_wide","","Converts a 512-bit little endian integer into an element…",29,[[],["fr",3]]],[11,"from_raw","","Converts from an integer represented in little endian into…",29,[[],["fr",3]]],[11,"square","","Squares this element.",29,[[],["fr",3]]],[11,"random","","Generate a valid Scalar choosen uniformly using user-…",29,[[],["fr",3]]],[11,"sqrt","","Computes the square root of this element, if it exists.",29,[[],[["fr",3],["ctoption",3]]]],[11,"pow","","Exponentiates `self` by `by`, where `by` is a…",29,[[],["fr",3]]],[11,"pow_vartime","","Exponentiates `self` by `by`, where `by` is a…",29,[[],["fr",3]]],[11,"invert","","Computes the multiplicative inverse of this element,…",29,[[],[["fr",3],["ctoption",3]]]],[11,"mul","","Multiplies this element by another element",29,[[["fr",3]],["fr",3]]],[11,"sub","","Subtracts another element from this element.",29,[[["fr",3]],["fr",3]]],[11,"add","","Adds this element to another element.",29,[[["fr",3]],["fr",3]]],[11,"neg","","Negates this element.",29,[[],["fr",3]]],[11,"reduce","","Reduces bit representation of numbers, such that they can…",29,[[],["fr",3]]],[11,"is_even","","Evaluate if a `Scalar, from Fr` is even or not.",29,[[]]],[11,"mod_2_pow_k","","Compute the result from `Scalar (mod 2^k)`.",29,[[]]],[11,"mods_2_pow_k","","Compute the result from `Scalar (mods k)`.",29,[[]]],[11,"compute_windowed_naf","","Computes the windowed-non-adjacent for a given an element…",29,[[]]]],"p":[[3,"Proof"],[3,"AggregateProof"],[3,"Commitment"],[4,"KZG10Errors"],[3,"OpeningKey"],[3,"CommitKey"],[3,"PublicParameters"],[4,"WireData"],[3,"StandardComposer"],[3,"Point"],[3,"PointScalar"],[3,"EvaluationDomain"],[3,"Evaluations"],[3,"Polynomial"],[3,"BlsScalar"],[3,"ProverKey"],[3,"VerifierKey"],[4,"PreProcessingError"],[4,"FFTErrors"],[13,"InvalidEvalDomainSize"],[4,"ProofErrors"],[3,"Proof"],[3,"Prover"],[3,"Verifier"],[8,"TranscriptProtocol"],[3,"PolyCommitSchemeError"],[3,"Variable"],[3,"ProvingError"],[3,"FFTError"],[3,"JubJubScalar"],[3,"ProofError"]]}\
}');
addSearchOptions(searchIndex);initSearch(searchIndex);